<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Extending python</title>
        <meta name="description" content="Extending python">
        <meta name="author" content="Andrey Antukh">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <link rel="stylesheet" href="css/reveal.min.css">
        <link rel="stylesheet" href="css/theme/serif.css" id="theme">
        <link rel="stylesheet" href="css/modifications.css">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
            document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>
    <body>
        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section>
                    <h1>Extending python</h1>
                    <h3>With Boost.Python, Ctypes and Cffi</h3>
                    <p>
                        <small>Created by <a href="http://www.niwi.be">Andrey Antukh</a> / <a href="http://twitter.com/niwibe">@niwibe</a></small>
                    </p>
                </section>

                <section>
                    <section>
                        <h2>C++ & Boost::Python</h2>

                        <h4>Goals:</h4>
                        <ul>
                            <li>Performance comparable to native C API</li>
                            <li>Many types with automatic conversions from C++ to python and from python to C++</li>
                            <li>Easily integrated with native C API</li>
                            <li>Can delegate the garbage collector to python or manage a memory yourself</li>
                        </ul>
                        <h4>Weaknesses</h4>
                        <ul>
                            <li>No native bytes support with python3 (always translate std::string to python str)</li>
                            <li>The documentation can be improved</li>
                            <li>The learning curve is slightly high.</li>
                        </ul>
                    </section>

                    <section>
                        <h2>First method (hello world)</h2>
                        <pre><code contenteditable>#include &lt;boost/python.hpp&gt;
#include &lt;iostream&gt;

namespace py = boost::python;

void print_helloworld() {
    std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;
}

BOOST_PYTHON_MODULE(example1) {
    py::def("print_helloworld", &::print_helloworld);
}</code></pre>

                        <pre><code contenteditable>&gt;&gt;&gt; import example1
&gt;&gt;&gt; example1.print_helloworld()
Hello World</code></pre>
                    </section>
                    <section>
                        <h2>First class</h2>
                        <pre><code contenteditable>#include &lt;boost/python.hpp&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

namespace py = boost::python;

class Foo {
public:
    Foo(const std::string &name) {
        this-&gt;name = name;
    }

    void say_hello() {
        std::cout &lt;&lt; "Hello " &lt;&lt; this-&gt;name &lt;&lt; "!" &lt;&lt; std::endl;
    }

private:
    std::string name;
};

BOOST_PYTHON_MODULE(example2) {
    py::class_<Foo>("Foo", py::init<std::string>())
        .def("say_hello", &Foo::say_hello);
}</code></pre>

                        <pre><code contenteditable>&gt;&gt;&gt; import example2
&gt;&gt;&gt; example2.Foo("Andrey").say_hello()
Hello Andrey!</code></pre>
                    </section>

                    <section>
                        <h2>Call python methods from c++</h2>

                        <pre><code contenteditable>#include &lt;boost/python.hpp&gt;

namespace py = boost::python;

int length1(const py::object &obj) {
    return py::call_method<int>(obj.ptr(), "__len__");
}

int length2(const py::object &obj) {
    return py::extract<int>(obj.attr("__len__")());
}

BOOST_PYTHON_MODULE(example3) {
    py::def("length1", &::length1);
    py::def("length2", &::length2);
}</code></pre>

                        <pre><code contenteditable>&gt;&gt;&gt; import example3
&gt;&gt;&gt; example3.length1([1,2,3])
3
&gt;&gt;&gt; example3.length2([1,2,3])
3</code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Ctypes</h2>
                        <h4>It mainly used to wrap c / c++ libraries in pure python.</h4>
                    </section>
                    <section>
                        <h2>Ctypes</h2>
                        <p style="margin-top:15px">
                            <ul>
                                <li>Requires low knowledge of c</li>
                                <li>Very portable, works well on python, pypy, ironpython, jython.</li>
                                <li>Low performance ovehead</li>
                                <li>Can not easy track c library api changes.</li>
                            </ul>
                        </p>
                    </section>
                    <section>
                        <h2>Loading a library</h2>
                        <pre><code contenteditable>&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; import ctypes.util
&gt;&gt;&gt; pathname = ctypes.util.find_library('mhash')
&gt;&gt;&gt; print(pathname)
libmhash.so.2
&gt;&gt;&gt; lib = ctypes.CDLL(pathname)
&gt;&gt;&gt; lib
&lt;CDLL 'libmhash.so.2', handle 11a90e0 at 7f9e4bfede10&gt;</code></pre>
                    </section>
                    <section>
                        <h2>Call some method</h2>
                        <pre><code>&gt;&gt;&gt; lib.mhash_inits
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python3.3/ctypes/__init__.py", line 366, in __getattr__
    func = self.__getitem__(name)
  File "/usr/lib/python3.3/ctypes/__init__.py", line 371, in __getitem__
    func = self._FuncPtr((name_or_ordinal, self))
AttributeError: /usr/lib/libmhash.so.2: undefined symbol: mhash_inits
&gt;&gt;&gt; lib.mhash_init
<_FuncPtr object at 0x7f9e4c046a10>
&gt;&gt;&gt; ptr = lib.mhash_init(17)
&gt;&gt;&gt; ptr
18476304
&gt;&gt;&gt; type(ptr)
<class 'int'>
&gt;&gt;&gt; lib.mhash_init.argtypes = [ctypes.c_int]
&gt;&gt;&gt; lib.mhash_init.restype = ctypes.c_void_p
&gt;&gt;&gt; ptr = lib.mhash_init(17)
&gt;&gt;&gt; ptr
18516192</code></pre>
                    </section>
                    <section>
                        <h2>Real example (py-mhash)</h2>
                        <pre><code>import ctypes
import ctypes.util

def load_library():
    libpath = ctypes.util.find_library('mhash')
    return ctypes.CDLL(libpath)

MHASH_TIGER160  = 15
MHASH_SHA256    = 17

try:
    lib = load_library()
    lib.mhash_init.argtypes = [ctypes.c_int]
    lib.mhash_init.restype = ctypes.c_void_p
    lib.mhash.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int]
    lib.mhash_end.argtypes = [ctypes.c_void_p]
    lib.mhash_end.restype = ctypes.c_char_p
    lib.mhash_get_block_size.argtypes = [ctypes.c_int]
    lib.mhash_get_block_size.restype = ctypes.c_int
except (OSError, IOError, AttributeError):
    raise ImportError('mhash shared library not found or incompatible')</code></pre>
                    </section>
                    <section>
                        <h2>Real example (continuation)</h2>
                        <pre><code>from . import api
import binascii

class sha256(object):
    def __init__(self, data=None):
        self.td = api.lib.mhash_init(api.MHASH_SHA256)
        self._result = None

        if not isinstance(data, bytes):
            raise RuntimeError("data must be bytes instance")
        api.lib.mhash(self.td, data, len(data))

    def hexdigest(self):
        if self._result is not None:
            return binascii.hexlify(self._result)

        size = api.lib.mhash_get_block_size(self._hash_type)
        self._result = api.lib.mhash_end(self.td)
        if len(self._result) > size:
            self._result = self._result[:size]
        return binascii.hexlify(self._result)</code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>CFFI</h2>
                        <h4>Foreign Function Interface for Python calling C code.</h4>
                    </section>

                    <section>
                        <h2>Loading a c library</h2>
                        <pre><code contenteditable>>>> from cffi import FFI
>>> ffi = FFI()
>>> ffi.cdef("""
...     int printf(const char *format, ...);   // copy-pasted from the man page
... """)
>>> C = ffi.dlopen(None)                     # loads the entire C namespace
>>> arg = ffi.new("char[]", "world")         # equivalent to C code: char arg[] = "world";
>>> C.printf("hi there, %s!\n", arg)         # call printf
hi there, world!</code></pre>

                    </section>
                    <section>
                        <h2>Real example (py-mhash-cffi)</h2>
                        <pre><code contenteditable>from cffi import FFI
ffi = FFI()
ffi.cdef("""
typedef enum __hashid {
        MHASH_TIGER128          = 14,
        MHASH_SHA256            = 17,
} hashid;

typedef uint32_t mutils_word32;
typedef uint8_t mutils_word8;
typedef char mutils_boolean;
typedef void (*INIT_FUNC)( void*);
typedef void (*HASH_FUNC)(void*, const void*, int);
typedef void (*FINAL_FUNC)(void*);
typedef void (*DEINIT_FUNC)(void*, unsigned char*);

typedef struct __MHASH_INSTANCE {
        mutils_word32 hmac_key_size;
        mutils_word32 hmac_block;
        mutils_word8 *hmac_key;
        mutils_word8 *state;
        mutils_word32 state_size;
        hashid algorithm_given;
        HASH_FUNC hash_func;
        FINAL_FUNC final_func;
        DEINIT_FUNC deinit_func;
} MHASH_INSTANCE;
typedef MHASH_INSTANCE *MHASH;

MHASH mhash_init(hashid type);
mutils_boolean mhash(MHASH thread, const void *plaintext, mutils_word32 size);
mutils_word32 mhash_get_block_size(hashid type);
void *mhash_end(MHASH thread);
""")

lib = ffi.dlopen("mhash")</code></pre>
                    </section>
                    <section>
                        <h2>Real example (continuation)</h2>
                        <pre><code contenteditable>import api
import binascii

class sha256(object):
    def __init__(self, data=None):
        self.td = api.lib.mhash_init(17)
        self._result = None
        if not isinstance(data, bytes):
                raise RuntimeError("data must be bytes instance")

        _data = api.ffi.new("char[]", data)
        api.lib.mhash(self.td, _data, len(data))

    def digest(self):
        if self._result is not None:
            return binascii.hexlify(self._result)

        _size = api.lib.mhash_get_block_size(17)
        _result = api.lib.mhash_end(self.td)
        self._result = api.ffi.buffer(_result, _size)
        return binascii.hexlify(self._result)</code></pre>
                    </section>
                </section>


                <section>
                    <h1>THE END</h1>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.min.js"></script>
        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });
        </script>
    </body>
</html>
